# Disassembly representation
The disassembly is represented, for the most part, as a list of instructions, which themselves are split into expression segments of operations and constants. An instruction is a "super-segment" of operations and constants. The only other "super-segment" is the control flow: which is a super-segment of operations and wasm expressions. For simplicity of parsing, the expression includes an end instruction, as well as the super-segment. This may be reverted in either direction, or more formally be set in stone at a later date
## Value in the representation
As it stands, the representation carries little about the actual operation: unlike a register machine, most of what an operation does (the exact "registers" it operates on) has more to do with position than it does with the opcode itself: x64 code might have an operation "mov eax, ecx", which is represented with an r/m byte internally but that our decompiler represents with instruction (assignment), dst (eax), and src (ecx) internally, the operation "i64.add" has *no* information beyond what is obvious from just the instruction: it will add the "top 2 values" and then "push the output to the top", which this project assumes will not change in location for a reasonable program.
What this really means though, is that most useful disassembly information comes from further analysis. Not only that, but the important outcome of this analysis will be needed at every individual instruction, instead of being more local to specific areas of instructions (e.g. `mov`s require data flow analysis, but if a `mov` is followed by another `mov`, it doesn't change the meaning of each individual instruction. `i64.get`s, on the other hand, do change meaning when repeated: they are not idempotent)
## other representations
The only other obvious representation is a tree, but it feels too early in the process for a tree to be necessary. Likely the tree will be needed very close to this point, but i don't think it's required yet.